#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
全数字的倍数

将192分别与1、2、3相乘：
192 × 1 = 192
192 × 2 = 384
192 × 3 = 576
连接这些乘积，我们得到一个1至9全数字的数192384576。我们称192384576为192和(1,2,3)的连接乘积。
同样地，将9分别与1、2、3、4、5相乘，得到1至9全数字的数918273645，即是9和(1,2,3,4,5)的连接乘积。
对于n > 1，所有某个整数和(1,2, … ,n)的连接乘积所构成的数中，最大的1至9全数字的数是多少？

分析：
一个数从1 往上乘，上限的是自己（连接起来有9位数就行），然后连接起来，那么可以先设定范围
1 位数：只可能有 9 [1、2、3、4、5]
2 位数：[1、2、3、4] *3 不进位，*4 进位的数 上限为 33
3 位数：[1、2、3] *3 不进位的数 上限为 333
4 位数：[1、2] *2 进位的数 下限为 5000 上限 9999
5 位数及以上，没有了
初略看出，这所有数中最大的必定是9开头的，这就先过滤掉 2 位数和 3 位数，因为最大也只有 3 开头的数

以 918273645 为标准以则只需要 9182-9999 的数进行比较了
"""
import re

find_Pandigital = re.compile(r"(?!\d*?(\d)\d*?\1)[1-9]{9,}")
decimals_1 = 918273645
decimals_5 = {decimals_1, 0}
for i in range(9182, 10000):
    i_num = str(i * 1) + str(i * 2)
    # 用list拆开，set去重，过滤掉有重复数字的
    # total_num = int(i_num) if len(set(list(i_num)))==9 and "0" not in i_num else 0
    total_num = int(i_num) if find_Pandigital.search(i_num) else 0
    decimals_5.add(total_num)

print(max(decimals_5))
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
异或解密

计算机上的每个字符都被指定了一个独特的代码，其中被广泛使用的一种是ASCII码（美国信息交换标准代码）。例如，大写字母A = 65，
星号（*） = 42，小写字母k = 107。

一种现代加密方法是将一个文本文档中的符号先转化为ASCII码，然后将每个字节异或一个根据密钥确定的值。使用异或进行加密的好处
在于，只需对密文使用相同的密钥再加密一次就能得到明文，例如，65 XOR 42 = 107，而107 XOR 42 = 65。

为了使加密难以破解，密钥要和明文一样长，由随机的字节构成。用户会把加密过的信息和密钥放置在不同的地方，解密时二者缺一不可。

不幸的是，这种方法对大多数人来说并不实用，因此一个略有改进的方法是使用一个密码作为密钥。密码的长度很有可能比信息要短，这
时候就循环重复使用这个密码进行加密。这种方法需要达到一种平衡，一方面密码要足够长才能保证安全，另一方面需要充分短以方便记
忆。

你的破解任务要简单得多，因为密钥只由三个小写字母构成。文本文档cipher.txt（右击并选择“目标另存为……”）中包含了加密后的
ASCII码，并且已知明文包含的一定是常见的英文单词，解密这条消息并求出原文的ASCII码之和。

分析：
因为是三个小写字母构成，所以密码是以三个字母为一组对整个密文进行对应匹配【三个字母是有序的】
所以需要把整个密文拆成3份，第147...个字符为1组  第258...个字符为一组  第369...个字符为一组
猜测整个字符表中最多的是空格，所以用空格的asc异或最多的asc码，得到三个key字母的asc
重复排列key到和密文一样长，并且一一对应，然后用key去异或密文，得到的字母拼接起来
"""

def xxx(guess=32):
    with open(r"p059_cipher.txt", "r") as rr:
        ll = rr.readline()
    ll = [int(i) for i in ll.split(",")]  # 调整数据为列表

    key = []
    for i in range(3):  # 3是因为只有三个字母
        depart = [x for x in ll[i::3]]  # 按3字节一循环分组
        key.append(max(depart, key=depart.count))  # 把最多的重复的加入列表

    key = [x ^ guess for x in key]  # 反转出key，32为猜测值（空格）
    key_asc = key * int(len(ll) / 3)  # 复制密码循环和密文一样长
    letter = [chr(x ^ y) for x, y in zip(ll, key_asc)]  # 一一匹配后 异或处理，用asc转为字母
    cipher = "".join(letter)  # 拼接结果
    asc_sum = sum([ord(x) for x in cipher])
    return cipher, asc_sum